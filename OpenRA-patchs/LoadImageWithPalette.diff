diff --git a/OpenRA.Game/Graphics/ChromeProvider.cs b/OpenRA.Game/Graphics/ChromeProvider.cs
index 29b107db1..8f315b386 100644
--- a/OpenRA.Game/Graphics/ChromeProvider.cs
+++ b/OpenRA.Game/Graphics/ChromeProvider.cs
@@ -11,7 +11,9 @@
 
 using System.Collections.Generic;
 using System.Linq;
+using OpenRA.FileFormats;
 using OpenRA.FileSystem;
+using OpenRA.Primitives;
 
 namespace OpenRA.Graphics
 {
@@ -86,7 +88,7 @@ static void LoadCollection(string name, MiniYaml yaml)
 			collections.Add(name, collection);
 		}
 
-		public static Sprite GetImage(string collectionName, string imageName)
+		public static Sprite GetImage(string collectionName, string imageName, IPalette palette = null)
 		{
 			if (string.IsNullOrEmpty(collectionName))
 				return null;
@@ -109,15 +111,38 @@ public static Sprite GetImage(string collectionName, string imageName)
 				return null;
 
 			// Cached sheet
-			Sheet sheet;
+			Sheet sheet = null;
 			if (cachedSheets.ContainsKey(mi.Src))
 				sheet = cachedSheets[mi.Src];
 			else
 			{
 				using (var stream = fileSystem.Open(mi.Src))
-					sheet = new Sheet(SheetType.BGRA, stream);
-
-				cachedSheets.Add(mi.Src, sheet);
+				{
+					if (Png.Verify(stream))
+						sheet = new Sheet(SheetType.BGRA, stream);
+					else if (palette != null)
+					{
+						foreach (ISpriteLoader loader in Game.ModData.SpriteLoaders)
+						{
+							ISpriteFrame[] frames;
+							TypeDictionary metadata;
+							if (loader.TryParseSprite(stream, out frames, out metadata))
+							{
+								if (frames.Length > 0)
+								{
+									// will use only first frame if multiple frames available
+									sheet = new Sheet(SheetType.BGRA, frames[0], palette);
+									break;
+								}
+							}
+						}
+					}
+
+					if (sheet == null)
+						return null;
+
+					cachedSheets.Add(mi.Src, sheet);
+				}
 			}
 
 			// Cache the sprite
diff --git a/OpenRA.Game/Graphics/Sheet.cs b/OpenRA.Game/Graphics/Sheet.cs
index 5a5df7efd..83b8ed142 100644
--- a/OpenRA.Game/Graphics/Sheet.cs
+++ b/OpenRA.Game/Graphics/Sheet.cs
@@ -58,6 +58,16 @@ public Sheet(SheetType type, Stream stream)
 			ReleaseBuffer();
 		}
 
+		public Sheet(SheetType type, ISpriteFrame frame, IPalette palette)
+		{
+			Size = new Size(frame.FrameSize.Width, frame.FrameSize.Height).NextPowerOf2();
+			data = new byte[4 * Size.Width * Size.Height];
+			Util.FastCopyIntoSprite(new Sprite(this, new Rectangle(0, 0, Size.Width, Size.Height), TextureChannel.Red), frame, palette);
+
+			Type = type;
+			ReleaseBuffer();
+		}
+
 		public ITexture GetTexture()
 		{
 			if (texture == null)
diff --git a/OpenRA.Game/Graphics/Util.cs b/OpenRA.Game/Graphics/Util.cs
index bc849d6b1..a3a97d383 100644
--- a/OpenRA.Game/Graphics/Util.cs
+++ b/OpenRA.Game/Graphics/Util.cs
@@ -121,6 +121,35 @@ public static void FastCopyIntoSprite(Sprite dest, Png src)
 			}
 		}
 
+		public static void FastCopyIntoSprite(Sprite dest, ISpriteFrame src, IPalette palette)
+		{
+			var destData = dest.Sheet.GetData();
+			var destStride = dest.Sheet.Size.Width;
+			var width = src.FrameSize.Width;
+			var height = src.FrameSize.Height;
+
+			unsafe
+			{
+				// Cast the data to an int array so we can copy the src data directly
+				fixed (byte* bd = &destData[0])
+				{
+					var data = (int*)bd;
+					var x = dest.Bounds.Left;
+					var y = dest.Bounds.Top;
+
+					var k = 0;
+					for (var j = 0; j < height; j++)
+					{
+						for (var i = 0; i < width; i++)
+						{
+							Color cc = Color.FromArgb(palette[src.Data[k++]]);
+							data[(y + j) * destStride + x + i] = PremultiplyAlpha(cc).ToArgb();
+						}
+					}
+				}
+			}
+		}
+
 		public static Color PremultiplyAlpha(Color c)
 		{
 			if (c.A == byte.MaxValue)
